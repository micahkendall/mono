// some very readable aiken code
use aiken/builtin use aiken/dict use aiken/list use aiken/transaction.{InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,Transaction, WithdrawFrom} use aiken/transaction/credential.{Address, ScriptCredential} use aiken/transaction/value type Datum {string:ByteArray,pointer:ByteArray}type Redeemer {New Insert{onto:ByteArray,insert: ByteArray,pointer:ByteArray}} fn is_alphanum(str: ByteArray)->Bool{let l=builtin.length_of_bytearray(str) l==0||{let h=builtin.index_bytearray(str,0)
((97<=h&&h<=122)||(48<=h&&h<=57))&&is_alphanum(builtin.slice_bytearray(1,l,str))}} fn valid_listitem(output: Output,own_pol: ByteArray,string: ByteArray,pointer: ByteArray){let Output{datum,address,value,reference_script}=output expect [_,(lock_p,lockdict)]=value|>value.to_dict|>dict.to_list expect [(locked_token_name, 1)] = lockdict |> dict.to_list let new_datum_raw: Data = Datum { string, pointer } let new_datum = InlineDatum(new_datum_raw) and{datum==new_datum,address==Address(ScriptCredential(own_pol),None),lock_p==own_pol,locked_token_name=="",builtin.less_than_bytearray(string,pointer),reference_script==None}} validator(genesis_utxo: OutputReference,fee_pol: ByteArray,fee_tkn: ByteArray){fn spend(_,__,c:ScriptContext) {expect ScriptContext {transaction: Transaction { inputs, redeemers, .. },purpose: Spend(own_ref)} = c expect Some(Input {output: Output { address: Address(ScriptCredential(own_pol), ..), .. },..}) = inputs |> list.find(fn(inp) { inp.output_reference == own_ref }) dict.has_key(redeemers, Mint(own_pol))} fn mint(r: Redeemer, ctx: ScriptContext) {expect ScriptContext{transaction:Transaction{inputs,mint,outputs,redeemers,reference_inputs,..},purpose:Mint(own_pol)}=ctx when r is {New->list.any(inputs,fn(inp){inp.output_reference==genesis_utxo})Insert{onto,insert,pointer}->{expect [(lock_tkn, 1), (new_tkn, 1)] = mint |>value.from_minted_value|>value.tokens(own_pol)|>dict.to_list expect [mint_input] = inputs |> list.filter(fn(inp) {inp.output.address == Address(ScriptCredential(own_pol), None)}) expect [continuing_output, new_output, ..] = outputs expect Some(Input {output: Output {address: Address(_, Some(fee_stk)),.. },..}) = reference_inputs |> list.find(fn(inp) {value.quantity_of(inp.output.value, fee_pol, fee_tkn) == 1}) and {is_alphanum(insert),builtin.length_of_bytearray(insert) <= 20,valid_listitem(mint_input.output, own_pol, onto, pointer),valid_listitem(continuing_output, own_pol, onto, insert),valid_listitem(new_output, own_pol, insert, pointer),lock_tkn == "",new_tkn == insert,dict.has_key(redeemers, WithdrawFrom(fee_stk))}}}}}
